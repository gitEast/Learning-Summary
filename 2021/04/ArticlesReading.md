# Reading an English article every week
## What every computer science major should know
### by Matthew Might
Given the expansive grownth in the field, it's become challenging to discern what belongs in a modern coonputer science degree.

My own faculty is engaging in this debate, so I've coalesced my thoughts as an answer to the question, "What should every computer science major known?"

I've tried to answer this question as the conjunction of four concerns:

+ What should every student know to get a good job?
+ What should every student know to maintain lifelong employment?
+ What should every student know to enter graduate school?
+ What should every student know to benefit society?

My thouts below factor into both general principles and specific recommendations relevant to the modern computing landscape.

Computer science majors: feel free to use this as a self-study guide.

Please email or tweet with suggestions for addtion and deletion.

**Upate**: Thanks for the suggestions and reminders! I'll incorporate them as I receive them to keep this a living document.

### Portfolio versus resume
Having emerged from engineering and mathematics, computer scuence programs take a resume-based approach to hiring off their graduates.

A resume says nothing of a programmer's ability.

Every computer secience major should build a portfolio.

A portforlio could be as simple as a personal blog, with a post for each project or accomplishment. A better portfolio would include per-project pages, and publicly browsable code(hosted perhaps on github or Google code).

Contributions to open source should be linked and documented.

A code portfolio allows emplouers to directly judge ability.

GPAs and resumes do not.

Professors should design course projects to impress on portfolios, and students, at the conclusion of each course, should take time to update them.

### Technical communication
Lone wolves in computer science are an endagered species.

Modern computer scientists must practice persuasively and clearly communicating their ideas to non-programmers.

In smaller companies, whether or not a programmer can communicate her ideas to management may make the difference between the company's success and failure.

Unfortunately, this is not something fixed with the addition of a single class(although a solid course in technical communication doesn't hurt).

More classes need to provide students the opportunity to present their work and defend their ideas with oral presentations.

#### Specific recommendations

I would recommend that students master a presentation tool like PowerPoint or (my favorite)Keynote.(Sorry, as much as I love them, LaTeX-based presentation tools are just too static).

For producing beautiful mathematical documentation, LaTeX has no equal.All written assignments in technical courses should be submitted in LaTeX.

### An engineering core
Computer science is not quite engineering.

But, it's close enough.

Computer scientists will find themselves working with engineers.

Computer scientists and traditional engineers need to speak the same language--a language rooted in real analysis, linear algebra, probablity and physics.

Computer scientists ought to take physics through electromagnetism. But, to do that, they'll need take up through multivariate calculus, (and differential equations for good measure).

In constructing sound simulations, a command of probability and (often times) linear algebra is invaluable. In interpreting results, there is no substitute for a solid understanding of statistics.

### The Unix philosophy
Computer scientists should be comfortable with and practiced in the Unix philosophy of computing.

The Unix philosophy(as opposed to Unix itself) is one that emphasizes linguistic abstraction and composition in order to effect computation.

In practice, this means becoming comfortable with the notion of command-line computing, text-file configuration and IDE-less softeare development.

#### Specific recommendations
Given the prevalence of Unix systems, computer scientists today should be fluent in basic Unix, including the ability to:

+ navigate and manipulate the filesystem;
+ compose processes with pipes;
+ create, modify and execute a Makefile for a software project;
+ write simple shell scripts.

Students will reject the Unix philosophy unless they understand its power. Thus, it's best to challenge students to complete useful tasks for which Unix has a comparative advantage, such as:

+ Find the five folders in a given directory consuming the most space.
+ Report duplicate MP3s(by file contents, not file name) on a computer.
+ Take a list of names whose first and last names have been lower-cased, and properly recapitalize them.
+ Find all words in English that have x as their second letter and n as their seconde-to-lase.
+ Directly route your microphone input over the network to anthoer computer's speaker.
+ Replace all spaces in a filename with underscore for a given directory.
+ Report the last ten errant accesses to the web server coming from a specific IP address.